RateLimiter.create(100.0, Duration.ofSeconds(5)) 的作用详解
这个调用创建了一个带有预热期的速率限制器（Rate Limiter），下面我将详细解释它的工作原理和实际效果：

核心参数解析
100.0：

表示稳定状态下的速率限制为 每秒100个请求
即最终会达到每秒允许100次操作
Duration.ofSeconds(5)：

表示预热期为 5秒
系统会在5秒内从冷启动状态逐渐达到最大速率
实际行为特点
预热期行为（前5秒）
不是立即达到100请求/秒的速率
速率会从低值平滑递增到目标速率
例如：
第1秒：可能只允许20个请求
第2秒：可能允许40个请求
...
第5秒：达到100请求/秒的稳定速率
稳定期行为（5秒后）
严格维持100请求/秒的速率
每个请求间隔约10ms（1000ms/100）
为什么要用预热期？
防止冷启动冲击：

当系统刚启动时，直接承受最大流量可能导致：
数据库连接池瞬间打满
缓存未预热导致大量请求穿透到数据库
服务线程瞬间耗尽
平滑流量增长：

给依赖服务（如数据库、外部API）适应时间
让缓存逐步填充
避免突发流量：

防止因突发流量导致系统崩溃
代码示例
java
RateLimiter limiter = RateLimiter.create(100.0, Duration.ofSeconds(5));

void handleRequest(Request request) {
    if (limiter.tryAcquire()) {
        // 处理请求
        process(request);
    } else {
        // 限流降级
        sendTooManyRequestsResponse();
    }
}
监控建议
预热期监控：

java
// 获取当前实际速率
double actualRate = limiter.getRate();
重要指标：

预热期间被拒绝的请求数
实际达到稳定速率的时间
系统资源使用率（CPU、内存、线程池等）
与其他创建方式的对比
创建方式	特点	适用场景
create(100.0)	立即达到最大速率	简单限流，能承受突发流量
create(100.0, Duration.ofSeconds(5))	5秒预热期	保护冷启动系统
create(100.0, Duration.ZERO, true)	公平模式	需要严格按请求顺序处理
这种带预热期的限流器特别适合以下场景：

微服务启动时的自我保护
需要初始化资源的操作（如建立连接池）
对突发流量敏感的后端系统